<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Birds Flocking</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #000;
    }

    canvas {
      background-color: #fff;
    }
  </style>
</head>

<body>
  <canvas id="birds_flocking" width="800" height="600"></canvas>
  <script src="../src/vector.js"></script>
  <script>

    const canvas = document.getElementById('birds_flocking');

    function Boid(position, velocity) {
      if (!(this instanceof Boid)) {
        return new Boid(position, velocity);
      }
      return {
        position: position,
        velocity: velocity,
        acceleration: new Vector.Vec2(0, 0),
        maxSpeed: 10,
        maxForce: 0.05,
        applyForce: function (force) {
          this.acceleration = this.acceleration.add(force);
        },
        update: function () {
    this.velocity = this.velocity.add(this.acceleration);
    if (this.velocity.magnitude() > this.maxSpeed) {
        this.velocity = this.velocity.unit().scale(this.maxSpeed);
    }
    this.position = this.position.add(this.velocity);
    this.acceleration = Vector.Vec2(0, 0);

    // Keep the boids within the canvas bounds
    if (this.position.x < 0) {
        this.position.x = 0;
    } else if (this.position.x > canvas.width) {
        this.position.x = canvas.width;
    }
    if (this.position.y < 0) {
        this.position.y = 0;
    } else if (this.position.y > canvas.height) {
        this.position.y = canvas.height;
    }
}

      };
    }

    function Flock() {
      if (!(this instanceof Flock)) {
        return new Flock();
      }
      return {
        boids: [],
        addBoid: function (boid) {
          this.boids.push(boid);
        },
        run: function () {
          this.boids.forEach(boid => {
            this.flock(boid);
            boid.update();
          });
        },
        flock: function (boid) {
          const separation = this.separate(boid);
          const alignment = this.align(boid);
          const cohesion = this.cohere(boid);

          boid.applyForce(separation.scale(1.5));
          boid.applyForce(alignment.scale(1.0));
          boid.applyForce(cohesion.scale(1.0));
        },
        separate: function (boid) {
          const desiredSeparation = 25.0;
          let steer = new Vector.Vec2(0, 0);
          let count = 0;
          this.boids.forEach(other => {
            const distance = boid.position.sub(other.position).magnitude();
            if (distance > 0 && distance < desiredSeparation) {
              const diff = boid.position.sub(other.position).unit().scale(1 / distance);
              steer = steer.add(diff);
              count++;
            }
          });
          if (count > 0) {
            steer = steer.scale(1 / count);
          }
          if (steer.magnitude() > 0) {
            steer = steer.unit().scale(boid.maxSpeed).sub(boid.velocity);
            if (steer.magnitude() > boid.maxForce) {
              steer = steer.unit().scale(boid.maxForce);
            }
          }
          return steer;
        },
        align: function (boid) {
          const neighborDist = 50;
          let sum = new Vector.Vec2(0, 0);
          let count = 0;
          this.boids.forEach(other => {
            const distance = boid.position.sub(other.position).magnitude();
            if (distance > 0 && distance < neighborDist) {
              sum = sum.add(other.velocity);
              count++;
            }
          });
          if (count > 0) {
            sum = sum.scale(1 / count).unit().scale(boid.maxSpeed);
            const steer = sum.sub(boid.velocity);
            if (steer.magnitude() > boid.maxForce) {
              return steer.unit().scale(boid.maxForce);
            }
            return steer;
          }
          return new Vector.Vec2(0, 0);
        },
        cohere: function (boid) {
          const neighborDist = 50;
          let sum = new Vector.Vec2(0, 0);
          let count = 0;
          this.boids.forEach(other => {
            const distance = boid.position.sub(other.position).magnitude();
            if (distance > 0 && distance < neighborDist) {
              sum = sum.add(other.position);
              count++;
            }
          });
          if (count > 0) {
            sum = sum.scale(1 / count);
            return this.seek(boid, sum);
          }
          return new Vector.Vec2(0, 0);
        },
        seek: function (boid, target) {
          const desired = target.sub(boid.position).unit().scale(boid.maxSpeed);
          const steer = desired.sub(boid.velocity);
          if (steer.magnitude() > boid.maxForce) {
            return steer.unit().scale(boid.maxForce);
          }
          return steer;
        }
      };
    }

    // Simulation parameters
const flock =  new Flock();
function reset() {
  flock.boids = [];
  for (let i = 0; i < 50; i++) {
    const position = new Vector.Vec2(Math.random() * canvas.width, Math.random() * canvas.height);
    const angle = Math.random() * 2 * Math.PI;
    const velocity = new Vector.Vec2(Math.cos(angle) * 40 - 20, Math.sin(angle) * 40 - 20);
    flock.addBoid(new Boid(position, velocity));
  }
}


// Add event listener to reset the simulation when the canvas is clicked
canvas.addEventListener('click', function() {
  reset();
  simulate();
});


    // Simulation loop
    function simulate() {
      flock.run();
      drawBoids(flock.boids);
      // logBoidData(flock.boids); // Log boid data
  window.requestAnimationFrame(simulate);
    }

    // Function to log boid positions and velocities
    function logBoidData(boids) {
      const data = boids.map(boid => {
        return {
          Position: { x: boid.position.x, y: boid.position.y },
          Velocity: { x: boid.velocity.x, y: boid.velocity.y }
        };
      });
      console.table(data);
    }


    // Drawing function (using a simple canvas for visualization)
    function drawBoids(boids) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      boids.forEach(boid => {
        drawTriangle(ctx, boid.position, boid.velocity);
      });
    }

    function drawTriangle(ctx, position, velocity) {
      const angle = Math.atan2(velocity.y, velocity.x);
      const size = 10; // Adjust the size of the triangle here

      // Scale the canvas context based on the velocity magnitude
      const scaleFactor = Math.min(50 / Math.max(Math.abs(velocity.x), Math.abs(velocity.y)), 1);
      ctx.scale(scaleFactor, scaleFactor);

      ctx.save();
      ctx.translate(position.x, position.y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, -size / 2);
      ctx.lineTo(size, 0);
      ctx.lineTo(0, size / 2);
      ctx.closePath();
      
      ctx.fillStyle = '#00f';
      ctx.fill();
      ctx.restore();
    }


    // Start the simulation
      window.addEventListener('load',function () {
          reset();
          simulate();
        });
    
    

  </script>
</body>

</html>