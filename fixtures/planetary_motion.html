<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Simulation</title>
    <style>
         body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }

        canvas {
            background-color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="solar_system"></canvas>
    <script type="module">

        import '../src/vector.js'; // Assuming this is the correct path to the vector module.

        const canvas = document.getElementById('solar_system');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Function to calculate squared distance between two vectors
        function distanceSquared(vector1, vector2) {
            const dx = vector2.x - vector1.x;
            const dy = vector2.y - vector1.y;
            const dz = vector2.z - vector1.z;
            return dx * dx + dy * dy + dz * dz;
        }

        class Sphere {
            constructor(position, mass, velocity, radius, color) {
                // Validate and set default values for position
                this.position = position || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for mass
                this.mass = (typeof mass === 'number' && !isNaN(mass) && mass > 0) ? mass : 1;

                // Validate and set default values for velocity
                this.velocity = velocity || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for radius
                this.radius = (typeof radius === 'number' && !isNaN(radius) && radius > 0) ? radius : 1;

                // Validate and set default values for color
                if (Array.isArray(color) && color.length === 4 && color.every(c => typeof c === 'number' && !isNaN(c))) {
                    this.color = color;
                } else {
                    this.color = [0, 0, 0, 1]; // Default color: black
                }
            }

            applyForce(force) {
                const acceleration = force.scale(1 / this.mass);
                this.velocity.add(acceleration);
            }

            updatePosition(timeStep) {
                this.position.add(this.velocity.scale(timeStep));
            }

            draw(ctx) {
                const numSegments = 50;
                for (let i = 0; i < numSegments; i++) {
                    const theta1 = (i / numSegments) * Math.PI;
                    const theta2 = ((i + 1) / numSegments) * Math.PI;

                    for (let j = 0; j < numSegments; j++) {
                        const phi1 = (j / numSegments) * 2 * Math.PI;
                        const phi2 = ((j + 1) / numSegments) * 2 * Math.PI;

                        const x1 = this.radius * Math.sin(theta1) * Math.cos(phi1) + this.position.x;
                        const y1 = this.radius * Math.sin(theta1) * Math.sin(phi1) + this.position.y;
                        const z1 = this.radius * Math.cos(theta1) + this.position.z;

                        const x2 = this.radius * Math.sin(theta2) * Math.cos(phi1) + this.position.x;
                        const y2 = this.radius * Math.sin(theta2) * Math.sin(phi1) + this.position.y;
                        const z2 = this.radius * Math.cos(theta2) + this.position.z;

                        const x3 = this.radius * Math.sin(theta2) * Math.cos(phi2) + this.position.x;
                        const y3 = this.radius * Math.sin(theta2) * Math.sin(phi2) + this.position.y;
                        const z3 = this.radius * Math.cos(theta2) + this.position.z;

                        const x4 = this.radius * Math.sin(theta1) * Math.cos(phi2) + this.position.x;
                        const y4 = this.radius * Math.sin(theta1) * Math.sin(phi2) + this.position.y;
                        const z4 = this.radius * Math.cos(theta1) + this.position.z;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.lineTo(x3, y3);
                        ctx.lineTo(x4, y4);
                        ctx.lineTo(x1, y1);
                        ctx.strokeStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.color[3]})`;
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }

        // Define celestial bodies
        const sun = new Sphere(new Vector.Vec3(canvas.width / 2, canvas.height / 2, 150), 1.989e30, new Vector.Vec3(0, 0, 0), 100, [255, 255, 0, 1]);
        const mercury = new Sphere(new Vector.Vec3(canvas.width / 2 + 57909175, canvas.height / 2, 0), 3.3011e23, new Vector.Vec3(0, 47872, 0), 5, [139, 69, 19, 1]);
        const venus = new Sphere(new Vector.Vec3(canvas.width / 2 + 108208930, canvas.height / 2, 0), 4.8675e24, new Vector.Vec3(0, 35020, 0), 6, [255, 165, 0, 1]);
        const earth = new Sphere(new Vector.Vec3(canvas.width / 2 + 149597890, canvas.height / 2, 0), 5.972e24, new Vector.Vec3(0, 29783, 0), 7, [0, 0, 255, 1]);

        // Array containing all celestial bodies
        const celestialBodies = [sun, mercury, venus, earth];

        // Main simulation loop
        function simulate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update positions and draw celestial bodies
            celestialBodies.forEach(body => {
                body.updatePosition(3600); // Time step: 1 hour
                body.draw(ctx);
            });

            requestAnimationFrame(simulate); // Continue the simulation
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        window.addEventListener('load', () => {
            simulate();
        });

    </script>
</body>
</html>
