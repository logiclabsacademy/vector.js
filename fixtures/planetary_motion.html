<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Simulation</title>
    <style>
          body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #000;
    }

    canvas {
      background-color: #fff;
    }
    </style>
</head>
<body>
    <canvas id="solar_system">
        <p>Your browser does not support the HTML5 Canvas Element!</p>
    </canvas>
    <script type="module">

        import '../src/vector.js'; // Assuming this is the correct path to the vector module.

        const canvas = document.getElementById('solar_system');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Function to calculate squared distance between two vectors
        function distanceSquared(vector1, vector2) {
            const dx = vector2.x - vector1.x;
            const dy = vector2.y - vector1.y;
            const dz = vector2.z - vector1.z;
            return dx * dx + dy * dy + dz * dz;
        }

        class Camera {
            constructor(canvas, distance, fov) {
                this.canvas = canvas;
                this.context = canvas.getContext('2d');
                this.distance = distance; // Distance from the camera to the view plane
                this.fov = fov; // Field of view

                this.position = new Vector.Vec3(canvas.width / 2, canvas.height / 2, 0); // Camera position
                this.orientation = new Vector.Vec3(0, 0, 1); // Camera orientation (looking direction)
                this.up = new Vector.Vec3(0, 1, 0); // Up vector
            }

            project(point) {
                // Project a 3D point onto the 2D canvas
                const dx = point.x - this.position.x;
                const dy = point.y - this.position.y;
                const dz = point.z - this.position.z;

                // Calculate projection onto the view plane
                const scaleFactor = this.distance / dz;
                const xProjected = this.canvas.width / 2 + dx * scaleFactor;
                const yProjected = this.canvas.height / 2 + dy * scaleFactor;

                return new Vector.Vec3(xProjected, yProjected, 0);
            }

            pan(dx, dy) {
                // Pan the camera by changing its position
                const right = this.orientation.cross(this.up).unit();
                const panX = right.scale(dx);
                const panY = this.up.scale(dy);
                this.position = this.position.add(panX).add(panY);
            }

            zoom(amount) {
                // Zoom the camera by changing its distance to the view plane
                this.distance += amount;
            }

            updateView() {
        // Clear canvas
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw celestial bodies
        celestialBodies.forEach(body => {
            const projectedPosition = this.project(body.position);
            // Draw body at the projected position
            body.draw(this.context); // Add this line
        });
    }
        }


        class Sphere {
            constructor(position, mass, velocity, radius, color) {
                // Validate and set default values for position
                this.position = position || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for mass
                this.mass = (typeof mass === 'number' && !isNaN(mass) && mass > 0) ? mass : 1;

                // Validate and set default values for velocity
                this.velocity = velocity || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for radius
                this.radius = (typeof radius === 'number' && !isNaN(radius) && radius > 0) ? radius : 1;

                // Validate and set default values for color
                if (Array.isArray(color) && color.length === 4 && color.every(c => typeof c === 'number' && !isNaN(c))) {
                    this.color = color;
                } else {
                    this.color = [0, 0, 0, 1]; // Default color: black
                }
            }

            applyForce(force) {
                const acceleration = force.scale(1 / this.mass);
                this.velocity.add(acceleration);
            }

            updatePosition(timeStep) {
                this.position.add(this.velocity.scale(timeStep));
            }

            draw(ctx) {
                const numSegments = 50;
                for (let i = 0; i < numSegments; i++) {
                    const theta1 = (i / numSegments) * Math.PI;
                    const theta2 = ((i + 1) / numSegments) * Math.PI;

                    for (let j = 0; j < numSegments; j++) {
                        const phi1 = (j / numSegments) * 2 * Math.PI;
                        const phi2 = ((j + 1) / numSegments) * 2 * Math.PI;

                        const x1 = this.radius * Math.sin(theta1) * Math.cos(phi1) + this.position.x;
                        const y1 = this.radius * Math.sin(theta1) * Math.sin(phi1) + this.position.y;
                        const z1 = this.radius * Math.cos(theta1) + this.position.z;

                        const x2 = this.radius * Math.sin(theta2) * Math.cos(phi1) + this.position.x;
                        const y2 = this.radius * Math.sin(theta2) * Math.sin(phi1) + this.position.y;
                        const z2 = this.radius * Math.cos(theta2) + this.position.z;

                        const x3 = this.radius * Math.sin(theta2) * Math.cos(phi2) + this.position.x;
                        const y3 = this.radius * Math.sin(theta2) * Math.sin(phi2) + this.position.y;
                        const z3 = this.radius * Math.cos(theta2) + this.position.z;

                        const x4 = this.radius * Math.sin(theta1) * Math.cos(phi2) + this.position.x;
                        const y4 = this.radius * Math.sin(theta1) * Math.sin(phi2) + this.position.y;
                        const z4 = this.radius * Math.cos(theta1) + this.position.z;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.lineTo(x3, y3);
                        ctx.lineTo(x4, y4);
                        ctx.lineTo(x1, y1);
                        ctx.strokeStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.color[3]})`;
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }
        // Define celestial bodies with initial positions and velocities
const sun = new Sphere(new Vector.Vec3(canvas.width / 2, canvas.height / 2, -250), 1.989e30, new Vector.Vec3(0, 0, 0), 50, [255, 255, 0, 1]); // Sun   
const mercury = new Sphere(new Vector.Vec3(canvas.width / 2 + 50, canvas.height / 2, -200), 3.285e23, new Vector.Vec3(0, 0.5, 0), 5, [192, 192, 192, 1]); // Mercury
const venus = new Sphere(new Vector.Vec3(canvas.width / 2 + 100, canvas.height / 2, -150), 4.867e24, new Vector.Vec3(0, 0.4, 0), 10, [255, 165, 0, 1]); // Venus
const earth = new Sphere(new Vector.Vec3(canvas.width / 2 + 150, canvas.height / 2, -100), 5.972e24, new Vector.Vec3(0, 0.3, 0), 10, [0, 0, 255, 1]); // Earth



// Array containing all celestial bodies
const celestialBodies = [sun, mercury, venus, earth];


function simulate() {
    ctx.fillStyle = '#fff'; // Set background color
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Clear canvas

    celestialBodies.forEach(body => {
        body.position.rotZ(1);
        body.updatePosition(3600);
        body.draw(ctx);
    });

    requestAnimationFrame(simulate);
}

// Resize canvas when the window is resized
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        window.addEventListener('load', () => {
            simulate();
        });

// Initialize camera
const camera = new Camera(canvas, 500, Math.PI / 4); // Adjust distance and field of view as needed

// Event listeners for panning and zooming
window.addEventListener('keydown', event => {
    switch (event.key) {
        case 'ArrowUp':
            camera.pan(0, -10); // Pan up
            break;
        case 'ArrowDown':
            camera.pan(0, 10); // Pan down
            break;
        case 'ArrowLeft':
            camera.pan(-10, 0); // Pan left
            break;
        case 'ArrowRight':
            camera.pan(10, 0); // Pan right
            break;
        case '+':
            camera.zoom(-10); // Zoom in
            break;
        case '-':
            camera.zoom(10); // Zoom out
            break;
        default:
            break;
    }

    camera.updateView(); // Update the view after panning or zooming
});


    </script>
</body>
</html>
