<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas {
            background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="solar_system">
        <p>Your browser does not support the HTML5 Canvas</p>
    </canvas>
    <script type="module">

    import '../src/vector.js';

    class Sphere {
        constructor(position, radius, color, nSegments = 50, orbitRadius = 20, orbitSpeed = 10) {
            this.position = position;
            this.radius = radius;
            this.color = color;
            this.nSegments = nSegments;
            this.orbitRadius = orbitRadius;
            this.orbitSpeed = orbitSpeed;
            this.orbitAngle = 0;
        }

        update() {
            this.orbitAngle += this.orbitSpeed;
            this.position.rotX(this.orbitAngle);

            if (this.orbitAngle >= 2 * Math.PI) {
                this.orbitAngle = 0;
            }
            return this;
        }

        draw(ctx, camera, viewport = { width: ctx.canvas.width, height: ctx.canvas.height }) {
            for (let i = 0; i < this.nSegments; i++) {
                const step = Math.sin(i * 2 * Math.PI / this.nSegments);
                const theta1 = i * 2 * Math.PI / this.nSegments;
                const theta2 = (i + 1) * 2 * Math.PI / this.nSegments;

                const x1 = this.position.x + this.radius * Math.cos(theta1);
                const y1 = this.position.y + this.radius * Math.sin(theta1) * step;
                const z1 = this.position.z;

                const x2 = this.position.x + this.radius * Math.cos(theta2);
                const y2 = this.position.y + this.radius * Math.sin(theta2);
                const z2 = this.position.z;

                const p1 = new Vector.Vec3(x1, y1, z1).project(camera.position, viewport);
                const p2 = new Vector.Vec3(x2, y2, z2).project(camera.position, viewport);

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = this.color;
                ctx.stroke();
                ctx.closePath();
            }
        }
    }

    class SolarSystem {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.stars = [];
        this.generateStars();
        this.lastUpdate = Date.now();

            this.camera = {
                position: new Vector.Vec3(0, 0, -75),
                distance: 50,
                lookAt: new Vector.Vec3(0, 0, 0),
                up: new Vector.Vec3(0, 1, 0),
                fov: 90,
            };

            this.viewport = {
                width: this.canvas.width,
                height: this.canvas.height
            };

            this.objects = [];
            this.stars = [];
            this.generateStars();
        }
drawStars() {
        this.stars.forEach(star => {
            this.ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
            this.ctx.fillRect(star.x, star.y, star.size, star.size);
        });
    }
        generateStars() {
            const numStars = 200;
            for (let i = 0; i < numStars; i++) {
                this.stars.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    size: Math.random() * 2, // Adjust the size of stars
                    brightness: Math.random() * 0.5 + 0.5 // Initial brightness
                });
            }
        }

        addObject(object) {
            this.objects.push(object);
        }

        

        update() {
        const now = Date.now();
        const deltaTime = now - this.lastUpdate;
        this.lastUpdate = now;

        // Update star brightness to create twinkling effect
        this.stars.forEach(star => {
            star.brightness += (Math.random() * 0.02 - 0.01) * (deltaTime / 1000); // Adjust the twinkling speed
            star.brightness = Math.max(0.1, Math.min(1, star.brightness)); // Clamp brightness between 0.1 and 1
        });

        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw stars
        this.drawStars();

        // Draw celestial bodies
        for (let object of this.objects) {
            object.update();
            object.draw(this.ctx, this.camera, this.viewport);
        }
    }
        animate() {
            this.update();
            window.requestAnimationFrame(this.animate.bind(this));
        }
    }

    const solarSystem = new SolarSystem('solar_system');

    const sun = new Sphere(new Vector.Vec3(0, 0, 0), 50, 'yellow');
    const mercury = new Sphere(new Vector.Vec3(100, 0, 0), 10, 'gray', 50, 0.1);
    const venus = new Sphere(new Vector.Vec3(150, 0, 0), 20, 'orange', 75, 0.08);
    const earth = new Sphere(new Vector.Vec3(200, 0, 0), 25, 'blue', 100, 0.07);
    const mars = new Sphere(new Vector.Vec3(250, 0, 0), 15, 'red', 125, 0.06);

    solarSystem.addObject(sun);
    solarSystem.addObject(mercury);
    solarSystem.addObject(venus);
    solarSystem.addObject(earth);
    solarSystem.addObject(mars);

    window.addEventListener('resize', () => {
        solarSystem.canvas.width = window.innerWidth;
        solarSystem.canvas.height = window.innerHeight;
        solarSystem.viewport = {
            width: solarSystem.canvas.width,
            height: solarSystem.canvas.height
        };
    });

    solarSystem.animate();
    </script>
</body>
</html>
