<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Simulation</title>
    <style>
         body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }

        canvas {
            background-color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="solar_system"></canvas>
    <script type="module">

        import '../src/vector.js'; // Assuming this is the correct path to the vector module.

        const canvas = document.getElementById('solar_system');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth - 50;
        canvas.height = window.innerHeight - 50;

        const sunRadius = 50;
        const sunMass = 1000;
        const sunColor = [255, 255, 0, 1]; // Yellow

        const planetRadius = 10;
        const planetMass = 10;
        const planetColor = [0, 0, 255, 1]; // Blue
        class Sphere {
            constructor(position, mass, velocity, radius, color) {
                // Validate and set default values for position
                this.position = position || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for mass
                this.mass = (typeof mass === 'number' && !isNaN(mass) && mass > 0) ? mass : 1;

                // Validate and set default values for velocity
                this.velocity = velocity || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for radius
                this.radius = (typeof radius === 'number' && !isNaN(radius) && radius > 0) ? radius : 1;

                // Validate and set default values for color
                if (Array.isArray(color) && color.length === 4 && color.every(c => typeof c === 'number' && !isNaN(c))) {
                    this.color = color;
                } else {
                    this.color = [0, 0, 0, 1]; // Default color: black
                }
            }

            applyForce(force) {
                const acceleration = force.scale(1 / this.mass);
                this.velocity.add(acceleration);
            }

            updatePosition(timeStep) {
                this.position.add(this.velocity.scale(timeStep));
            }

            draw(ctx) {
                const numSegments = 50;
                for (let i = 0; i < numSegments; i++) {
                    const theta1 = (i / numSegments) * Math.PI;
                    const theta2 = ((i + 1) / numSegments) * Math.PI;

                    for (let j = 0; j < numSegments; j++) {
                        const phi1 = (j / numSegments) * 2 * Math.PI;
                        const phi2 = ((j + 1) / numSegments) * 2 * Math.PI;

                        const x1 = this.radius * Math.sin(theta1) * Math.cos(phi1) + this.position.x;
                        const y1 = this.radius * Math.sin(theta1) * Math.sin(phi1) + this.position.y;
                        const z1 = this.radius * Math.cos(theta1) + this.position.z;

                        const x2 = this.radius * Math.sin(theta2) * Math.cos(phi1) + this.position.x;
                        const y2 = this.radius * Math.sin(theta2) * Math.sin(phi1) + this.position.y;
                        const z2 = this.radius * Math.cos(theta2) + this.position.z;

                        const x3 = this.radius * Math.sin(theta2) * Math.cos(phi2) + this.position.x;
                        const y3 = this.radius * Math.sin(theta2) * Math.sin(phi2) + this.position.y;
                        const z3 = this.radius * Math.cos(theta2) + this.position.z;

                        const x4 = this.radius * Math.sin(theta1) * Math.cos(phi2) + this.position.x;
                        const y4 = this.radius * Math.sin(theta1) * Math.sin(phi2) + this.position.y;
                        const z4 = this.radius * Math.cos(theta1) + this.position.z;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.lineTo(x3, y3);
                        ctx.lineTo(x4, y4);
                        ctx.lineTo(x1, y1);
                        ctx.strokeStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.color[3]})`;
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }


        // Define celestial bodies with initial positions and velocities
        const sun = new Sphere(new Vector.Vec3(canvas.width / 2, canvas.height / 2, -250), sunMass, new Vector.Vec3(0, 0, 0), sunRadius, sunColor); // Sun
        const mercury = new Sphere(new Vector.Vec3(canvas.width / 2, canvas.height / 2, -200), planetMass, new Vector.Vec3(0, 0, 0.01), planetRadius, planetColor); // Mercury
        const venus = new Sphere(new Vector.Vec3(canvas.width / 2 , canvas.height / 2, -150), planetMass, new Vector.Vec3(0, 0, 0.008), planetRadius, planetColor); // Venus
        const earth = new Sphere(new Vector.Vec3(canvas.width / 2, canvas.height / 2, -100), planetMass, new Vector.Vec3(0, 0, 0.006), planetRadius, planetColor); // Earth
        
        console.table(sun);
        console.table(mercury);
        console.table(venus);
        console.table(earth);
        
        // Array to hold all celestial bodies
        const celestialBodies = [sun, mercury, venus, earth];

        // Define camera position
        const cameraPosition = new Vector.Vec3(canvas.width / 2, canvas.height / 2, 500); // Adjust distance as needed

        // Function to draw the celestial bodies
        function drawCelestialBodies() {
            celestialBodies.forEach(body => {
                const projectedPosition = body.position.project(cameraPosition, { width: canvas.width, height: canvas.height });
                body.draw(ctx, projectedPosition);
            });
        }

        // Update function to simulate planet spinning
        function update() {
            // Update positions of celestial bodies
            celestialBodies.forEach(body => {
                // Simulate spinning around the sun
                const distanceToSun = body.position.distanceTo(sun.position);
                const angularSpeed = 0.001 / distanceToSun; // Adjust the speed based on distance
                body.position.rotZ(angularSpeed); // Spin around the z-axis (sun)
            });
        }

        // Render function to draw the scene
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCelestialBodies();
        }

        // Function to handle scroll events for rotating the camera
        function handleScroll(event) {
            cameraPosition.rotZ(event.deltaY * 0.01); // Adjust rotation speed as needed
            render();
        }

        // Event listener for scroll events
        window.addEventListener('scroll', handleScroll);

        // Main animation loop
        function animate() {
            update();
            render();
            requestAnimationFrame(animate);
        }

        // Start the animation loop
        animate();

    </script>
</body>
</html>
