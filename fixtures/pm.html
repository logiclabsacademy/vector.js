<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Simulation</title>
    <style>
         body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }

        canvas {
            background-color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="solar_system"></canvas>
    <script type="module">

        import '../src/vector.js'; // Assuming this is the correct path to the vector module.

        const canvas = document.getElementById('solar_system');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Function to calculate squared distance between two vectors
        function distanceSquared(vector1, vector2) {
            const dx = vector2.x - vector1.x;
            const dy = vector2.y - vector1.y;
            const dz = vector2.z - vector1.z;
            return dx * dx + dy * dy + dz * dz;
        }
        class Sphere {
            constructor(position, mass, velocity, radius, color) {
                // Validate and set default values for position
                this.position = position || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for mass
                this.mass = (typeof mass === 'number' && !isNaN(mass) && mass > 0) ? mass : 1;

                // Validate and set default values for velocity
                this.velocity = velocity || new Vector.Vec3(0, 0, 0);

                // Validate and set default values for radius
                this.radius = (typeof radius === 'number' && !isNaN(radius) && radius > 0) ? radius : 1;

                // Validate and set default values for color
                if (Array.isArray(color) && color.length === 4 && color.every(c => typeof c === 'number' && !isNaN(c))) {
                    this.color = color;
                } else {
                    this.color = [0, 0, 0, 1]; // Default color: black
                }
            }

            applyForce(force) {
                const acceleration = force.scale(1 / this.mass);
                this.velocity.add(acceleration);
            }

            updatePosition(timeStep) {
                this.position.add(this.velocity.scale(timeStep));
            }

            draw(ctx) {
                const numSegments = 50;
                for (let i = 0; i < numSegments; i++) {
                    const theta1 = (i / numSegments) * Math.PI;
                    const theta2 = ((i + 1) / numSegments) * Math.PI;

                    for (let j = 0; j < numSegments; j++) {
                        const phi1 = (j / numSegments) * 2 * Math.PI;
                        const phi2 = ((j + 1) / numSegments) * 2 * Math.PI;

                        const x1 = this.radius * Math.sin(theta1) * Math.cos(phi1) + this.position.x;
                        const y1 = this.radius * Math.sin(theta1) * Math.sin(phi1) + this.position.y;
                        const z1 = this.radius * Math.cos(theta1) + this.position.z;

                        const x2 = this.radius * Math.sin(theta2) * Math.cos(phi1) + this.position.x;
                        const y2 = this.radius * Math.sin(theta2) * Math.sin(phi1) + this.position.y;
                        const z2 = this.radius * Math.cos(theta2) + this.position.z;

                        const x3 = this.radius * Math.sin(theta2) * Math.cos(phi2) + this.position.x;
                        const y3 = this.radius * Math.sin(theta2) * Math.sin(phi2) + this.position.y;
                        const z3 = this.radius * Math.cos(theta2) + this.position.z;

                        const x4 = this.radius * Math.sin(theta1) * Math.cos(phi2) + this.position.x;
                        const y4 = this.radius * Math.sin(theta1) * Math.sin(phi2) + this.position.y;
                        const z4 = this.radius * Math.cos(theta1) + this.position.z;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.lineTo(x3, y3);
                        ctx.lineTo(x4, y4);
                        ctx.lineTo(x1, y1);
                        ctx.strokeStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.color[3]})`;
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }

        // Initialize camera position
        const cameraPosition = new Vector.Vec3(canvas.width / 2, canvas.height / 2, 500); // Adjust distance as needed
        // Define celestial bodies with initial positions and velocities
        const sun = new Sphere(new Vector.Vec3(canvas.width / 2, canvas.height / 2, -250), 1, new Vector.Vec3(0, 0, 0), 50, [255, 255, 0, 1]); // Sun
        const mercury = new Sphere(new Vector.Vec3(canvas.width / 2 + 100, canvas.height / 2, -250), 0.0553, new Vector.Vec3(0, 0, 0.0001), 5, [192, 192, 192, 1]); // Mercury
        const venus = new Sphere(new Vector.Vec3(canvas.width / 2 + 150, canvas.height / 2, -250), 0.815, new Vector.Vec3(0, 0, 0.0001), 10, [255, 165, 0, 1]); // Venus
        const earth = new Sphere(new Vector.Vec3(canvas.width / 2 + 200, canvas.height / 2, -250), 1, new Vector.Vec3(0, 0, 0.0001), 10, [0, 0, 255, 1]); // Earth
        const celestialBodies = [sun, mercury, venus, earth];

        // Event listeners for panning and zooming
        window.addEventListener('keydown', event => {
            switch (event.key) {
                case 'ArrowUp':
                    cameraPosition.y -= 10; // Pan up
                    break;
                case 'ArrowDown':
                    cameraPosition.y += 10; // Pan down
                    break;
                case 'ArrowLeft':
                    cameraPosition.x -= 10; // Pan left
                    break;
                case 'ArrowRight':
                    cameraPosition.x += 10; // Pan right
                    break;
                case '+':
                    cameraPosition.z -= 10; // Zoom in
                    break;
                case '-':
                    cameraPosition.z += 10; // Zoom out
                    break;
                default:
                    break;
            }

            // Update the view after panning or zooming
            celestialBodies.forEach(body => {
                const projectedPosition = body.position.project(cameraPosition, { width: canvas.width, height: canvas.height });
                body.draw(ctx, projectedPosition);

            });
        });

    </script>
</body>
</html>
